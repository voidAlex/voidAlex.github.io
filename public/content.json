{"meta":{"title":"voidAlex的记事本","subtitle":"长路漫漫，唯剑作伴","description":null,"author":"voidAlex","url":"https://voidalex.one"},"pages":[{"title":"关于","date":"2017-03-02T08:56:49.000Z","updated":"2018-02-20T11:53:00.000Z","comments":false,"path":"about/index.html","permalink":"https://voidalex.one/about/index.html","excerpt":"","text":"我目前就读于西北师范大学，专业是计算机科学与技术，2018年本科毕业。 喜欢音乐，喜欢足球篮球，喜欢摄影，喜欢骑行，喜欢游戏，喜欢瞎折腾。 会一点Java Web，会一点爬虫，会一点数据挖掘，会一点机器学习。 努力学习中~ 有问题欢迎微博交流，也可以发邮件：wangld1994@gmail.com 博客Hexo是一个快速，简单，强大的博客框架，使用教程可以参考这里。 主题：Next 评论：Disqus 分享按钮：AddThis 站内搜索：Algolia 访问统计：不蒜子 图床：七牛云+极简图床"},{"title":"categories","date":"2018-02-20T02:42:55.000Z","updated":"2018-02-20T10:43:14.000Z","comments":false,"path":"categories/index.html","permalink":"https://voidalex.one/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-02T08:57:05.000Z","updated":"2018-02-20T10:42:44.000Z","comments":false,"path":"tags/index.html","permalink":"https://voidalex.one/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一种在服务器上部署Hexo博客的思路","slug":"一种在服务器上部署Hexo博客的思路","date":"2018-02-19T05:01:00.000Z","updated":"2018-02-21T09:31:01.149Z","comments":true,"path":"2018/02/19/一种在服务器上部署Hexo博客的思路/","link":"","permalink":"https://voidalex.one/2018/02/19/一种在服务器上部署Hexo博客的思路/","excerpt":"","text":"前言笔者在过年期间买了域名和VPS，打算迁移博客到VPS上（GitHub Page访问速度实在是……你懂得）。由于平时使用的主力语言是Java，所以找了两个开源的Java博客系统Solo和Tale，试用了之后发现都有不满意的地方，比如说： 主题少 有广告（虽然是开源的能理解，但是强迫症接受不了……） 不支持MathJax渲染（虽然自己加上了，但还是有问题，强迫症同样无法接受……） …… 思来想去还是hexo好，遂决定把hexo部署在服务器上。搜了一下发现大家都是把VPS当做Git服务器在用，然后用Nginx去解析静态资源。这种方式本质上和托管在GitHub上没什么区别，无非就是解析速度快点而已。这样做除了加快解析速度外，并没有任何好处。写一篇博文还是要经历创建文件--写博文--预览--生成静态资源--使用Git同步这么一个过程。而且在更换电脑后必须配置Node.js、Git、Hexo等一大堆东西之后才能写，等于花VPS的钱，只起到了一个加速效果。 好在Hexo还有hexo-server和hexo-admin这样的插件。之前并没有觉得hexo-admin这样的插件有什么用，但是在VPS上，它的价值体现出来了。于是，一个部署的思路诞生了： 使用hexo-server作为hexo的服务器 使用hexo-admin作为hexo的管理后台 使用Nginx作为反向代理服务器 使用Git与GitHub仓库同步（可选） 这样的话，等于给Hexo博客多了一个后台。成功部署后在本地只需要一个浏览器就可以美滋滋的写博客了~ 阅读前方内容需要一定的基础，假设你已经在GitHub Page上成功的部署了你的博客，并且有一定的Linux基础知识。如果你还没有使用过Hexo，那么可以先看看官方文档和这篇教程。 （题外话）域名和VPS在国内购买服务器和域名需要备案。为了避免麻烦笔者选择了狗爹和vultr。VPS套餐选择的是每个月5刀的套餐，配置只有1核CUP和1GB内存（编译Node.js用了40分钟），但是已经足够。 服务器的环境配置服务器配置的所有操作均为在Ubuntu 16.04下的操作。 安装Node.jsHexo是在Node.js上构建的博客系统，通过Node.js将.md文件渲染为.html文件。所以，安装Node.js必不可少。 安装Node.js的方法很多，笔者选择下载源码编译安装。注意，编译安装的时间长短视你的服务器配置而定，笔者的小水管上编译了40多分钟才玩。 首先安装gcc、g++、make、python等编译解释环境：12sudo apt update #老版本Ubuntu请使用apt-getsudo apt install gcc g++ make python 获取Node.js的源码：12wget http://nodejs.org/dist/latest-v8.x/node-v8.9.4.tar.gztar zxvf node-v8.9.4.tar.gz 开始安装：123cd node-v8.9.4./configure #如果gcc、make等依赖未安装会报错make install #安装时间较长 安装完成之后验证：12node -vv8.9.4 安装Nginx并配置反向代理Nginx在Ubuntu下的安装较为简单，直接通过apt源即可安装： 12sudo apt updatesudo apt install nginx 启动Nginx：1service nginx start 在浏览器中输入你的服务器ip进行验证（不用加端口号），如果能看见Nginx的欢迎页面说明安装成功。 编辑/etc/nginx/nginx.conf，配置反向代理：12345678server &#123; listen 80; #监听端口，默认为http请求的80端口 server_name voidalex.one; #你的域名 location / &#123; proxy_pass http://localhost:4000/; #代理转发，你的hexo服务器的地址 &#125;&#125; 保存完毕，执行service nginx reload重启Nginx服务器。 配置DNS解析在你购买的域名服务商的控制面板中，配置DNS解析，IP为你的服务器公网IP（不加端口）。设置完毕稍等一会（DNS服务器需要刷新缓存），访问你的域名即可看到Nginx的欢迎页面。 本地配置Hexo安装插件在服务器运行Hexo需要依赖于hexo-server和hexo-admin。如果你在本地已经安装这两个插件，请跳过这一步。（当然你也可以直接copy你的hexo博客目录到服务器上安装这两个插件，不过在本地先安装方便调试） cd到你的博客根目录下，执行：12npm install hexo-server@0.3.1 --savenpm install hexo-admin@2.3.0 --save 安装完毕后，执行：1hexo s 打开浏览器，访问http://localhost:4000 即可预览博客，访问http://localhost:4000/admin 即可进入hexo-admin后台管理界面。 配置hexo-adminhexo-admin默认没有开启密码保护，需要自己手动开启。 访问http://localhost:4000/admin 点击Settings--Setup authentification here进行密码设置： 输入用户名、密码后，将生成的代码复制： 然后打开博客根目录下的_config.yml，将复制的代码粘贴到末尾。 重新启动hexo服务器，访问http://localhost:4000/admin 如果出现登录界面，则配置成功。 将Hexo博客迁移至服务器很简单，将你的整个博客目录打包，然后上传到服务器，然后解包。你在本地使用npm安装的hexo插件都在博客根目录下的node_modules目录下。如果你没有动这个目录，那么在服务器上解包之后就能直接用了。解包推荐使用unzip。 123unzip blog.zipcd bloghexo s 如果一切正常，访问你的域名就可以看到博客了，访问域名/admin就能进入到后台界面。 Tips：如果执行hexo相关命令报错的话，按照博客根目录下package.json中列出的插件名和版本重新按照一遍就好了。如：npm install hexo@3.5.0 --save 善后工作实际上，到上一步已经成功的把Hexo部署在服务器上了。但是为了获得更好的体验还是需要再进行一些配置。 后台运行hexo直接使用hexo s启动服务器，Ctrl+C或者shell关掉就结束进程了。可以使用nohup来后台运行hexo。在博客根目录下，执行： 1nohup hexo s &amp; 这样hexo就会运行在后台，输出的日志会被记录在nohup.out中。 优化解析速度部署好了，但是加载速度仍然很慢。原因是每次访问的时候hexo都会动态的去加载.md文件，然后由Node.js渲染成html，再展示出来。看到hexo的官方文档中提了这么一句： 重启服务器之后，果然加载快了很多很多。 然而，这样启动服务器，你在后台编辑过的文章都不会被加载出来。需要你手动的执行hexo g命令，才能加载出来。 强迫症是忍受不了这样的操作的，好在hexo-admin中提供了这样一个功能： 点击按钮就能执行你的部署脚本。在博客根目录下的_config.yml中添加配置：12admin: deployCommand: &apos;./hexo-deploy.sh&apos; 然后在博客根目录下创建hexo-deploy.sh，并编辑：12#!/usr/bin/env shhexo g 给hexo-deploy.sh授予权限：1chmod a+x hexo-deploy.sh 重启服务器，编辑博文后点击Deploy按钮就可以把文章渲染成html页面来访问了。 与GitHub Page同步如果想在服务器上和原仓库同步的话，只需要配置Git，然后修改部署脚本就行了。Git的安装和配置不在赘述，要注意的是服务器上安装的Git不是用来配置Git服务器的，而是当做一个用户来提交代码的。配置完记得在你的GitHub中添加秘钥。 配置完之后，只需要修改hexo-deploy.sh就可以了：12#!/usr/bin/env shhexo g -d 然后重启服务器，以后每次点击deploy按钮时都会把渲染的html页面提交到GitHub仓库里。输出信息如下图： 如果看到这些信息，说明配置没有问题，代码已经提交成功了。 验证一下： 安利一下安利几个好东西吧。 狗爹，全球最大的域名服务商 vultr，美帝的VPS提供商，按分钟计费。推荐每个月5刀的套餐，硅谷节点（千万不要选新加坡和日本节点，很容易被墙而且速度奇慢） Moeditor，十分简洁舒服的Markdown编辑器 indigo，很好看的一个Hexo主题","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://voidalex.one/tags/配置/"},{"name":"杂记","slug":"杂记","permalink":"https://voidalex.one/tags/杂记/"}]},{"title":"理解Spring中的依赖注入","slug":"理解Spring中的依赖注入","date":"2017-11-09T12:55:00.000Z","updated":"2017-11-10T09:24:10.000Z","comments":true,"path":"2017/11/09/理解Spring中的依赖注入/","link":"","permalink":"https://voidalex.one/2017/11/09/理解Spring中的依赖注入/","excerpt":"这是voidAlex原创的第十七篇博文。","text":"这是voidAlex原创的第十七篇博文。 依赖注入和控制翻转IoC(Inversion of Control，控制翻转)和DI(Dependency Injection，依赖注入)在Spring下是同等的概念。控制翻转是通过依赖注入来实现的。依赖注入是指由容器负责创建对象和负责维护对象间的依赖关系，从而实现解耦，体现一种组合的理念。 任何一个实际的应用，都会由两个或者更多的类组成。这些类之间相互调用以完成特定的业务逻辑。每个对象负责管理和调用与自己相互协作的对象，这会导致高度耦合的代码。 耦合具有两面性。一方面，高度耦合的代码将会难以测试，难以复用，难以理解，并且会表现出“打地鼠”式的bug特性（修复一个bug，又出现更多的新bug）。但是，一定程度的耦合又是必须的，完全没有耦合的代码什么也做不了。为了完成特定的功能，不同的代码之间必须进行交互。 通过依赖注入，创建被调用者的工作不再由调用者来完成，而是由Spring容器来完成，然后注入到调用者。这也意味着，当需要切换依赖的时候，不需要改变调用者的代码。依赖关系将被自动注入到需要它们的对象当中去。 知乎上有个回答，总结的相当到位。原文点这里。 实例传统的做法考虑下面代码： 123456789101112public class JayChouCD &#123; public void play();&#125;public class CDPlayer &#123; private JayChouCD cd; public void playCD() &#123; this.cd = new JayChouCD(); this.cd.play(); &#125;&#125; 我们有一个CD机，它需要一张CD才能够播放，或者说，CDPlayer依赖于CD。在上面的代码中，我们直接通过new关键字给CDPlayer创建了一个JayChouCD的实例，这样我们就能在这个CD机上听周杰伦的歌了。 面向接口编程但是，这样做，我们能够听的歌十分有限，只能在这个CD机上听周杰伦的CD。考虑使用面向接口的编程方式改写上面的代码： 123456789101112public interface CD &#123; void play();&#125;public class CDPlayer &#123; private CD cd; public void playCD() &#123; this.cd = new JayChouCD(); this.cd.play(); &#125;&#125; 与CD机直接打交道的类变成了CD，即使它最终实现依然是JayChouCD，但是这样做已经有明显的好处，所有调用都通过接口CD来完成。需要替换JayChouCD类，想听其他人的歌时，也只需要修改CD指向新的实现类。 动态生成对象虽然上述代码已经很大程度的降低了耦合，但是耦合依然存在。想听其他人的歌曲时依然需要修改CDPlayer类内部的代码。当依赖过多的时候，修改起来会相当的麻烦。考虑通过反射机制中的动态加载类来修改上述代码： 12345678910111213141516public interface CD &#123; void play();&#125;public class CDPlayer() &#123; private static String CLASS_NAME = \"JayChouCD\"; private CD cd; public void playCD() &#123; Class class = Class.forName(CLASS_NAME); this.cd = (CD) class.newInstance(); this.cd.play(); &#125;&#125; 这样，我们动态的得到了CD的实例，不必每次都为听谁的歌而苦恼了，只需要告诉CD机类名即可。获得类名可以通过配置文件去实现。这样我们就实现了CD和CDPlayer间的解耦。实际上，Spring中DI的底层就是通过反射机制来实现的。 使用Spring的DI Spring支持使用xml、Java Config和注解去装配Bena。Spring Boot推荐使用注解和Java Config的方式。使用Spring Boot的方式继续改造上面的代码： 1234567891011121314151617181920212223public interface CD &#123; void play();&#125;@Componentpublic class JayChouCD implements CD &#123; private String title = \"哎呦，不错哦！\"; public void play() &#123; System.out.println(title); &#125;&#125;public class CDPlayer() &#123; @Autowired private CD cd; public void playCD() &#123; this.cd.play(); &#125;&#125; 首先使用@Component注解告诉Spring，这个类是一个让你进行管理的bean，这意味着在其他类中可以通过Spring的依赖注入来得到它的实例。所以，在CDPlayer类中，我们使用了@Autowired注解，来将一个CD注入到CDPlayer中。 Spring中，所有的Bean都通过IoC容器（ApplicationContext）来创建，并负责注入到需要的bean中。Spring Boot中，有四种常用的声明Bena的注解： @Component：组件，没有明确的角色 @Service：在业务逻辑层使用（Service层） @Repository：在数据访问层使用（dao层） @Controller：在展现层使用（MVC） 注入Bena的注解，一般情况下通用： @Autowried：Spring提供的注解 @Inject @Resource 这三个注解都可以用在属性、set方法、构造方法上。 总结 一句话：控制翻转是将对象的创建权翻转给Spring，依赖注入是在Spring创建对象的过程中，把对象依赖的属性注入到类中。控制翻转是通过依赖注入来实现的。 参考资料 《精通Spring 4.x 企业应用开发实战》 《Spring实战》 CSND博客：关于Spring IOC (DI-依赖注入)你需要知道的一切","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://voidalex.one/tags/Spring/"}]},{"title":"Docker容器间的互联","slug":"Docker容器间的互联","date":"2017-11-08T08:55:53.000Z","updated":"2017-11-10T09:26:57.000Z","comments":true,"path":"2017/11/08/Docker容器间的互联/","link":"","permalink":"https://voidalex.one/2017/11/08/Docker容器间的互联/","excerpt":"这是voidAlex原创的第十六篇博文。","text":"这是voidAlex原创的第十六篇博文。 在Docker中，容器间是相互独立的。各个容器有自己的进程空间、文件系统、网络空间等。然而，容器如果不能和外界通信，是没用什么卵用的。它们只有相互通信的时候才能发挥作用。 端口映射实际上，在之前使用Spring Boot和mysql的文章中已经在使用端口绑定了。在启动容器的时候可以可以加-p参数将容器的端口绑定到宿主机的端口： 1docker run -d --name myMysql --volumes-from sqldata -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 mysql 上面这条命令就是将mysql在容器中的3306端口映射到了宿主机的3307端口。然后通过宿主机的IP和端口，就能在外部访问这个mysql容器了。 容器链接使用容器链接可以更方便的实现容器间互联。将一个容器链接到另一个容器时，Docker会添加一些环境变量来获取关联容器之间的信息。在启动容器的时候使用--link参数来链接其他容器： 1docker run -p 8848:8848 --name jzfp --link myMysql -t jzfp/gsjzfp 启动后，该容器会将myMysql的网络信息以环境变量的形式添加到jzfp容器中，使得这个容器能够访问它。 实例在Docker部署Spring Boot应用，并且通过容器链接来访问mysql中的数据。 启动mysql容器首先启动一个mysql容器，映射到宿主机的8849端口： 1docker run -d --name myMysql --volumes-from sqldata -e MYSQL_ROOT_PASSWORD=123456 -p 8849:3306 mysql 进入容器，设置外部访问账户： 123docker exec -t -i myMysql /bin/bashmysql -uroot -pgrant all on *.* to 'test'@'%' identified by '1234'; 这时候，容器外部可以通过8849端口，使用test账户访问mysql。 配置Spring Boot数据库连接修改application.properties中的数据库连接配置： 1234spring.datasource.url = jdbc:mysql://myMysql:3306/jzfpsd?characterEncoding=UTF-8spring.datasource.username = testspring.datasource.password = 1234spring.datasource.driver-class-name = com.mysql.jdbc.Driver 可以看到，我们直接配置了数据库的IP地址为myMysql容器的名称。在启动该容器链接到myMysql后，即可通过Docker添加的环境变量去访问myMysql容器。 编译Spring Boot应用并生成镜像： 1mvn clean package -Dmaven.test.skip=true docker:build 启动Spring Boot容器，链接到mysql1docker run -p 8848:8848 --name jzfp --link myMysql -t jzfp/gsjzfp 总结使用Docker，即可在一台宿主机上实现数据库与WEB应用的分离。而且由于容器间链接和数据卷的特性，我们可以很方便的使用Docker打包数据文件和镜像，真正的实现一次打包，到处运行。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://voidalex.one/tags/Docker/"}]},{"title":"Docker下快速安装MySQL并使用数据卷容器","slug":"Docker下快速安装MySQL并使用数据卷容器","date":"2017-11-06T11:32:34.000Z","updated":"2017-11-10T09:26:22.000Z","comments":true,"path":"2017/11/06/Docker下快速安装MySQL并使用数据卷容器/","link":"","permalink":"https://voidalex.one/2017/11/06/Docker下快速安装MySQL并使用数据卷容器/","excerpt":"这是voidAlex原创的第十五篇博文。","text":"这是voidAlex原创的第十五篇博文。 数据卷和数据卷容器数据卷Docker下数据卷是一个可供容器直接使用的特殊目录，有如下特性： 数据卷可以在一个或多个容器见共享和重用 对数据卷的修改会立即生效 对数据卷的操作不影响镜像 数据卷的生命周期独立于容器 数据卷容器数据卷容器也是一个正常的容器，专门提供数据卷供其他容器挂载的。 创建数据卷容器创建一个名为sqldata的数据卷容器： 1docker run -d -v /data/mysql:/var/lib/mysql --name sqldata training/postgres 这个命令会创建一个名为sqldata的数据卷容器，并且将容器中的/var/lib/mysql目录映射到宿主机的/data/mysql下。 创建mysql容器并挂载数据卷容器首先拉去mysql的镜像： 1docker pull mysql 创建mysql容器，并挂载数据卷sqldata： 1docker run -d --name myMysql --volumes-from sqldata -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql 这个命令会创建一个MySQL容器，为root用户设置密码为123456，并且挂载sqldata数据卷。 进入到myMysql容器中，并且登录到mysql服务器： 12docker exec -t -i myMysql /bin/bashmysql -uroot -p 这时候，root用户只能通过localhost访问，增加用户，授予其对应权限： 1grant all on *.* to 'test'@'%' identified by '1234'; 创建test用户后，就可以以正常访问mysql数据库的方式远程访问myMysql容器了。 通过数据卷容器备份、恢复和迁移数据备份创建一个新容器，加载sqldata容器中的数据卷，并从主机挂载当前目录到容器的/backup目录。容器启动后，将sqldata数据卷备份为当前容器中的/backup/backup.tar文件。 1docker run --volumes-from sqldata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /data/mysql 恢复先创建一个带有空的数据卷的容器： 1docker run -v /data/mysql:/var/lib/mysql --name backupdata ubuntu /bin/bash 再创建另一个容器，挂载backupdata容器中的数据卷，解压备份文件到挂载的容器数据卷中： 1docker run --volumes-from backupdata -v $(pwd):/backup busybox tar xvf /backup/backup.tar","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://voidalex.one/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://voidalex.one/tags/MySQL/"}]},{"title":"CentOS 7下安装Docker并部署Spring Boot应用","slug":"CentOS7下安装Docker","date":"2017-11-06T02:07:09.000Z","updated":"2017-11-10T09:25:51.000Z","comments":true,"path":"2017/11/06/CentOS7下安装Docker/","link":"","permalink":"https://voidalex.one/2017/11/06/CentOS7下安装Docker/","excerpt":"这是voidAlex原创的第十四篇博文。","text":"这是voidAlex原创的第十四篇博文。 从内核和稳定性的角度考虑，Docker最好安装在Ubuntu 16.04上。但是在生产环境中，总是不可避免的使用CentOS。本文讲述在CentOS下安装Docker的过程。CentOS必须是64位，并且版本大于等于6.5。 配置静态IP先用ip addr查看网卡信息,得到： 1234567891: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:46:eb:2f brd ff:ff:ff:ff:ff:ff... 可以看到使用的网卡是ens33，所以再修改ifcfg-ens33文件的信息。 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改如下内容： 1234567BOOTPROTO=static #dhcp改为static ONBOOT=yes #开机启用本配置 IPADDR=202.201.53.161 #静态IP GATEWAY=202.201.53.129 #默认网关 NETMASK=255.255.255.0 #子网掩码 DNS1=202.201.48.1 #DNSDNS2=202.201.48.2 修改后效果： 123456789101112131415161718192021cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=0c7d8882-dc8a-4e0a-bb82-1bb36aac80a8DEVICE=ens33ONBOOT=yesIPADDR=202.201.53.161GATEWAY=202.201.53.129NETMASK=255.255.255.0DNS1=202.201.48.1DNS2=202.201.48.2 重启网络服务： 1service network restart 安装Docker使用脚本安装为了简化安装流程，直接使用官方提供的脚本自动安装： 12curl -fsSL get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun 启动Docker12systemctl enable dockersystemctl start docker 查看安装信息安装完毕后，使用docker version来查看安装信息： 12345678910111213141516Client: Version: 17.07.0-ce API version: 1.31 Go version: go1.8.3 Git commit: 8784753 Built: Tue Aug 29 17:42:01 2017 OS/Arch: linux/amd64Server: Version: 17.07.0-ce API version: 1.31 (minimum version 1.12) Go version: go1.8.3 Git commit: 8784753 Built: Tue Aug 29 17:43:23 2017 OS/Arch: linux/amd64 Experimental: false 建立Docker用户组123groupadd docker# 将当前用户加入docker组usermod -aG docker $USER 添加内核参数默认配置下，在CentOS使用Docker会看到这些警告信息： 12WARNING: bridge-nf-call-iptables is disabledWARNING: bridge-nf-call-ip6tables is disabled 添加内核配置信息启用这些功能： 1234tee -a /etc/sysctl.conf &lt;&lt;-EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF 重新加载sysctl.conf： 1sysctl -p 生成镜像并运行生成镜像和运行的步骤与在Ubuntu下的一样，在这里不再赘述。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://voidalex.one/tags/Docker/"},{"name":"配置","slug":"配置","permalink":"https://voidalex.one/tags/配置/"}]},{"title":"理解Docker中的三大核心概念：镜像、容器、仓库","slug":"理解Docker中的三大核心概念：镜像、容器、仓库","date":"2017-11-05T07:17:27.000Z","updated":"2017-11-05T14:29:29.000Z","comments":true,"path":"2017/11/05/理解Docker中的三大核心概念：镜像、容器、仓库/","link":"","permalink":"https://voidalex.one/2017/11/05/理解Docker中的三大核心概念：镜像、容器、仓库/","excerpt":"这是voidAlex原创的第十三篇博文。","text":"这是voidAlex原创的第十三篇博文。 镜像 Docker镜像（Image）是一个特殊的文件系统，里面包含了容器运行时所需要的程序、库、资源、配置等文件和一些为运行时准备的配置参数，如匿名卷、环境变量、用户等。之所以说他特殊是因为它不会包含任何动态数据，其内容在构建之后也不会被改变。镜像可以是一个完整是操作系统，可以是一个数据库，可以是一个服务器，甚至可以只是一个WEB应用。 Docker中的镜像并非是一个像ISO文件那样的打包文件，镜像只是一个虚拟的概念，实际体现并非由一个文件组成，而是由一组文件组成，或者说由多层文件联合组成。镜像在构建时，会一层一层构建，前一层是后一层的基础。每一层构建完就不会发生改变，后一层上的任何改变只是发生在自己这一层。分层存储的特征使得镜像的复用、定制变得更为容易。 容器容器（Container）的实质是进程，它是一个轻量级的沙箱，来隔离和运行应用。与直接在宿主机上执行的进程不同，容器的进程运行于自己独立的命名空间中。因此它可以拥有自己的进程空间、文件系统、网络空间、用户权限。容器内的进程运行在一个沙箱中，使用起来就好像一个独立于宿主的操作系统下操作一样。这种特性使得容器封装的应用运行更加安全。 容器也使用分层存储。每个容器运行时都会以镜像为基础层，在其上创建一个当前容器的存储层。存储层的生命周期和容器一样，容器消亡时，容器存储层也会消亡。 可以用面向对象程序设计中类和实例的关系来理解镜像和容器的关系。类和镜像都是静态的定义，容器和实例是运行时的实体，它们都可以被创建、删除，删除时，它们的数据也会随之消亡。 容器所有的文件写入操作，都应该使用数据卷或者绑定宿主目录。数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。 仓库仓库（Repository）类似于代码仓库，用来集中存储、分发镜像。根据所存储的镜像公开分享与否，仓库可以分为公开仓库和私有仓库。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://voidalex.one/tags/Docker/"}]},{"title":"Google Java Style Guide在IntelliJ IDEA中的配置","slug":"Google-Java-Style-Guide在IntelliJ-IDEA中的配置","date":"2017-11-04T12:01:52.000Z","updated":"2017-11-10T09:27:50.000Z","comments":true,"path":"2017/11/04/Google-Java-Style-Guide在IntelliJ-IDEA中的配置/","link":"","permalink":"https://voidalex.one/2017/11/04/Google-Java-Style-Guide在IntelliJ-IDEA中的配置/","excerpt":"这是voidAlex原创的第十二篇博文。","text":"这是voidAlex原创的第十二篇博文。 下载1git clone git@github.com:google/styleguide.git 配置在clone的仓库中找到intellij-java-google-style.xml这个文件，然后打开IDEA，File-&gt;Setting-&gt;Editor-&gt;Code Style-&gt;Java，把设置文件导入： 选择文件，然后点ok： 选择Google Style，配置完成：","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://voidalex.one/tags/配置/"},{"name":"杂记","slug":"杂记","permalink":"https://voidalex.one/tags/杂记/"}]},{"title":"使用Docker打包和部署Spring Boot应用","slug":"使用Docker打包和部署Spring-Boot应用","date":"2017-11-04T03:46:13.000Z","updated":"2017-11-10T09:29:52.000Z","comments":true,"path":"2017/11/04/使用Docker打包和部署Spring-Boot应用/","link":"","permalink":"https://voidalex.one/2017/11/04/使用Docker打包和部署Spring-Boot应用/","excerpt":"在Ubuntu 16.04下使用Docker部署Spring Boot应用。这是voidAlex原创的第十一篇博文。","text":"在Ubuntu 16.04下使用Docker部署Spring Boot应用。这是voidAlex原创的第十一篇博文。 DockerDocker简介简单的来说，Docker是一种容器，属于操作系统层面的虚拟化技术，基于Linux内核对进程进行封装隔离。Docker从文件系统、网络通信到进程隔离等等，极大的简化了容器的创建与维护，使得Docker比传统的虚拟机技术更加轻便快捷。 与虚拟机技术的比较传统虚拟机技术是虚拟出一套硬件，然后在其上运行一个完整的操作系统，在该系统上再运行所需要应用进程。而容器内的进程则直接运行在宿主的内核上，容器没有自己的内核，没有进行硬件虚拟。因此容器比传统的虚拟机更为轻便。 Docker的优势 更高效的利用系统资源 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 准备工作首先安装Oracle JDK和Maven，在编译Spring Boot应用时会用到。 12345678910sudo apt update# 配置安装源sudo apt install python-software-propertiessudo apt install software-properties-commonsudo add-apt-repository ppa:webupd8team/java# 安装Oracle JDKsudo apt updatesudo apt install oracle-java8-installer# 安装Mavensudo apt install maven 查看安装信息： 12java -versionmvn -v 确保JDK版本为8及以上，Maven版本为3及以上。 安装和配置Docker配置国内安装源12345678910111213sudo apt-get updatesudo apt-get install apt-transport-httpssudo apt-get install ca-certificatessudo apt-get install curlsudo apt-get install software-properties-commoncurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安装Docker CE12sudo apt-get updatesudo apt-get install docker-ce 脚本自动安装可以使用Docker官方提供的脚本来简化安装流程： 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 启动Docker123456sudo systemctl enable dockersudo systemctl start docker# 建立Docker用户组sudo groupadd docker# 将当前用户加入到用户组sudo usermod -aG docker $USER 配置Docker远程访问Docker默认不会监听任何端口，因此只能在本地使用Docker。如果先在其他机器上操作Docker主机，就要让Docker守护进程监听一个端口。修改Docker服务配置文件，添加一个未被占用的端口后，重启Docker服务： 1vi /etc/default/docker 添加： 12DOCKER_OPTS=\"-H 0.0.0.0:6000\"DOCKER_OPTS=\"-H unix:///var/run/docker.sock -H 0.0.0.0:5555\" 重启Docker： 1service docker restart Spring Boot应用配置配置Maven依赖在pom.xml中，加入这些内容： 123456789101112131415161718192021222324252627282930313233&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;docker.image.prefix&gt;jzfp&lt;/docker.image.prefix&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerHost&gt;http://host:port&lt;/dockerHost&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Spotify的docker-maven-plugin插件是用于构建Maven的Docker镜像。imageName指定了镜像的名称，dockerHost指定了Docker主机的地址，dockerDirectory指定了Dockerfile文件的路径。 配置Dockerfile在src/main/docker下创建Dockerfile，然后编辑： 12345FROM frolvlad/alpine-oraclejdk8VOLUME /tmpADD gsjzfp-0.0.1-SNAPSHOT.jar app.jarENV JAVA_OPTS=&quot;&quot;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ] 其中，FROM指定了当前镜像集成的基镜像为oraclejdk8；VOLUME指定了临时文件目录为/tmp，该配置会在/var/lib/docker下创建一个临时文件并链接到容器的/tmp目录下；ADD将该应用的jar文件作为app.jar添加到容器里；ENTRYPOINT执行app.jar。 打包运行编译并构建为Docker镜像将整个项目目录copy到Docker主机，cd到项目目录下，执行： 1mvn clean package docker:build 运行1docker run -p 8848:8848 -t jzfp/gsjzfp 如果程序运行正确，浏览器访问http://host:8848就能看到Spring Boot应用的主页了。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://voidalex.one/tags/Docker/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://voidalex.one/tags/Spring-Boot/"}]},{"title":"Java补锅笔记：利用反射获得对象的信息","slug":"Java补锅笔记：利用反射获得对象的信息","date":"2017-11-02T03:12:20.000Z","updated":"2017-11-10T09:28:32.000Z","comments":true,"path":"2017/11/02/Java补锅笔记：利用反射获得对象的信息/","link":"","permalink":"https://voidalex.one/2017/11/02/Java补锅笔记：利用反射获得对象的信息/","excerpt":"这是voidAlex原创的第十篇博文。","text":"这是voidAlex原创的第十篇博文。 Java中，类的Class类的实例对象，类的成员变量也是对象，它是java.lang.reflect.Field的实例对象。Field类封装了关于成员变量的操作。 同样的，类的方法也是对象，它是java.lang.reflect.Method的实例对象。Methon类封装了关于类方法的操作。 构造函数是java.lang.reflect.Constructor的实例对象。 通过反射获取对象的信息先声明一个普通的Student类： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by 王麟东 on 2017/11/2 0002 19:12. Email: wangld1994@gmail.com */public class Student &#123; private String name; private int age; private String id; public Student()&#123; &#125; public Student(String name, String id)&#123; this.name = name; this.id = id; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getId() &#123; return id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; Student类有三个私有的成员变量，一个带参数的构造方法和一个不带参数的构造方法，还有对各个成员变量的getter和setter方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * Created by 王麟东 on 2017/11/2 0002 18:01. Email: wangld1994@gmail.com */public class ClassMessage &#123; public static void getClassMessage(Object o)&#123; //获取类信息 Class c = o.getClass(); //获取类名称 System.out.println(\"类名称：\" + c.getName()); //获取所有的public函数，包括从父类继承而来的 Method[] methods = c.getMethods(); for (Method method : methods)&#123; //获得方法名 System.out.println(\"方法名：\" + method.getName()); //获得方法的返回类型 Class returnType = method.getReturnType(); System.out.println(\"返回类型：\" + returnType.getName()); //获得参数类型 Class[] paramTypes = method.getParameterTypes(); System.out.println(\"参数类型：\"); for (Class parmType : paramTypes)&#123; System.out.println(parmType.getName()); &#125; &#125; //获得所有成员变量 //getDeclaredFields获得的是该类自己声明的变量的信息 //getFields获得的是所有public的成员变量的信息 Field[] fields = c.getDeclaredFields(); System.out.println(\"成员变量：\"); for (Field field : fields)&#123; Class fieldType = field.getType(); System.out.println(fieldType.getName() + \" \" + field.getName()); &#125; //获得构造函数的信息 Constructor[] constructors = c.getDeclaredConstructors(); for (Constructor constructor : constructors)&#123; System.out.println(\"构造函数：\" + constructor.getName()); //获取构造函数的参数列表 System.out.println(\"参数类型：\"); Class[] cparamTypes = constructor.getParameterTypes(); for (Class cparamType : cparamTypes)&#123; System.out.println(cparamType.getName()); &#125; &#125; &#125;&#125; 测试运行： 123public static void main(String args[])&#123; Student student = new Student();ClassMessage.getClassMessage(student);&#125; 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263类名称：Student方法名：getName返回类型：java.lang.String参数类型：方法名：getId返回类型：java.lang.String参数类型：方法名：setName返回类型：void参数类型：java.lang.String方法名：setId返回类型：void参数类型：java.lang.String方法名：setAge返回类型：void参数类型：int方法名：getAge返回类型：int参数类型：方法名：wait返回类型：void参数类型：方法名：wait返回类型：void参数类型：longint方法名：wait返回类型：void参数类型：long方法名：equals返回类型：boolean参数类型：java.lang.Object方法名：toString返回类型：java.lang.String参数类型：方法名：hashCode返回类型：int参数类型：方法名：getClass返回类型：java.lang.Class参数类型：方法名：notify返回类型：void参数类型：方法名：notifyAll返回类型：void参数类型：成员变量：java.lang.String nameint agejava.lang.String id构造函数：Student构造函数：Studentjava.lang.Stringjava.lang.StringProcess finished with exit code 0 注意！在getDeclaredFields()方法中，有这么一句注释： 12* &lt;p&gt; The elements in the returned array are not sorted and are not in any* particular order. 这个注释告诉我们，用户不要在代码中依赖这些方法返回的顺序。它“不保证返回的顺序是怎样的”。这是因为在Java编译器与JVM中都有权利对Java类的字段做重排序。详细的信息可以参考：https://www.zhihu.com/question/52856385。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"补锅笔记","slug":"补锅笔记","permalink":"https://voidalex.one/tags/补锅笔记/"},{"name":"反射","slug":"反射","permalink":"https://voidalex.one/tags/反射/"}]},{"title":"Java补锅笔记：反射机制","slug":"Java补锅笔记：反射机制","date":"2017-11-02T00:39:31.000Z","updated":"2017-11-10T09:28:53.000Z","comments":true,"path":"2017/11/02/Java补锅笔记：反射机制/","link":"","permalink":"https://voidalex.one/2017/11/02/Java补锅笔记：反射机制/","excerpt":"这是voidAlex原创的第九篇博文。","text":"这是voidAlex原创的第九篇博文。 什么是反射能够分析类能力的程序成为反射（reflective）。Java的反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射机制可以用来： 在运行中分析类的能力； 在运行中查看对象,获取成员变量、接口、构造方法等； 动态创建和访问数组； 运行时复制对象 …… Class类在面向对象的世界里，一切皆对象。在Java中，只有静态成员变量和普通数据类型不是对象。类也是对象，它是java.lang.Class类的实例对象，任何一个类都是Class类的实例对象，并且一个类只有可能是Class类的一个实例对象。 在Class类的源码里，它的构造方法是私有的，上面有这么一段注释： 12345/* * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */ 所以，Class类无法通过构造方法去实例化，只有JVM虚拟机才能创建Class类的实例对象。获得一个Class类的实例对象有下面三种方法： 第一种方法直接通过类的隐含的成员变量class去获取1Class c1 = Student.class; 第二种方法，已知该类的实例对象，通过getClass方法去获取1Class c2 = student.getClass; 第三种方法，通过完整的类名获得1Class c3 = Class.forName(\"com.enity.Student\"); 所以我们可以通过该类的类类型来创建该类的实例对象，但是前提是该类需要有无参数的构造方法： 12Class c = Student.class;Student student = (Student) c.newInstance();","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"补锅笔记","slug":"补锅笔记","permalink":"https://voidalex.one/tags/补锅笔记/"},{"name":"反射","slug":"反射","permalink":"https://voidalex.one/tags/反射/"}]},{"title":"Gitlab不靠谱搭建指南","slug":"Gitlab不靠谱搭建指南","date":"2017-11-01T11:20:34.000Z","updated":"2017-11-10T09:27:45.000Z","comments":true,"path":"2017/11/01/Gitlab不靠谱搭建指南/","link":"","permalink":"https://voidalex.one/2017/11/01/Gitlab不靠谱搭建指南/","excerpt":"在Ubuntu 16.04下快速搭建Gitlab并汉化。这是voidAlex原创的第八篇博文。","text":"在Ubuntu 16.04下快速搭建Gitlab并汉化。这是voidAlex原创的第八篇博文。 配置ip使用ifconfig查看网卡名称，然后修改配置文件修改/etc/network/interfaces1sudo vi /etc/network/interfaces 将内容修改为： 12345auto ens33iface ens33 inet staticaddress 202.201.53.159gateway 202.201.53.128netmask 255.255.255.0 重启网络，使之生效：1sudo /etc/init.d/networking restart 配置DNS：1sudo vi /etc/resolvconf/resolv.conf.d/base 添加： 12nameserver 223.5.5.5nameserver 223.6.6.6 保存后执行： 1resolvconf -u 重启网络1sudo ifdown ens33 &amp;&amp; sudo ifup ens33 更新apt，安装ssh和git123sudo apt-get updatesudo apt install sshsudo apt install git 测试ssh安装是否成功： 1ssh localhost 安装Gitlab并配置依赖关系安装邮件服务器：1sudo apt-get install curl openssh-server ca-certificates postfix 配置安装源：1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash 安装Gitlab并初始化12sudo apt install gitlab-cesudo gitlab-ctl reconfigure 修改host修改/etc/gitlab/gitlab.rb中的external_url： 1external_url 'http://nwnu.git.com' 在/etc/hosts中添加hosts映射： 1127.0.0.1 nwnu.git.com 让Gitlab配置生效： 1sudo gitlab-ctl reconfigure 汉化Gitlab确定Gitlab的版本1sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION clone汉化版本库1git clone https://gitlab.com/xhang/gitlab.git 导出diff文件并补丁123sudo git diff v10.1.0 v10.1.0-zh &gt; ../10.1.0-zh.diffsudo gitlab-ctl stopsudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.1.0-zh.diff 重启Gitlab12sudo gitlab-ctl startsudo gitlab-ctl reconfigure 备份Gitlab默认的备份目录在/var/opt/gitlab/backups。 手动备份1sudo gitlab-rake gitlab:backup:create 自动备份12# 每天2点备份0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1 恢复恢复之前，确保备份文件所安装 GitLab 和当前要恢复的 GitLab 版本一致。首先，恢复配置文件： 123sudo mv /etc/gitlab /etc/gitlab.$(date +%s)# 将下面配置备份文件的时间戳改为你所备份的文件的时间戳sudo tar -xf etc-gitlab-1399948539.tar -C / 恢复数据文件： 123456789101112131415# 将数据备份文件拷贝至备份目录sudo cp 1393513186_gitlab_backup.tar /var/opt/gitlab/backups/# 停止连接数据库的进程sudo gitlab-ctl stop unicornsudo gitlab-ctl stop sidekiq# 恢复1393513186这个备份文件，将覆盖GitLab数据库！sudo gitlab-rake gitlab:backup:restore BACKUP=1393513186# 启动 GitLabsudo gitlab-ctl start# 检查 GitLabsudo gitlab-rake gitlab:check SANITIZE=true","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://voidalex.one/tags/配置/"},{"name":"Gitlab","slug":"Gitlab","permalink":"https://voidalex.one/tags/Gitlab/"}]},{"title":"算法笔记：Top-N算法及Java实现","slug":"算法笔记：Top-N算法及Java实现","date":"2017-08-21T15:17:43.000Z","updated":"2017-11-10T09:30:06.000Z","comments":true,"path":"2017/08/21/算法笔记：Top-N算法及Java实现/","link":"","permalink":"https://voidalex.one/2017/08/21/算法笔记：Top-N算法及Java实现/","excerpt":"这是voidAlex原创的第七篇博文。 给定一组无序的数据，需要创建一个最大的N条记录的列表，这类问题是经典的Top-N问题。","text":"这是voidAlex原创的第七篇博文。 给定一组无序的数据，需要创建一个最大的N条记录的列表，这类问题是经典的Top-N问题。 系统中常常会有这样的需求：将大量的（几百万甚至上千万）的数据排序,然后取出最Top的N条作为展示。常见的解决方案如下： 使用传统的排序算法，即使用List中的Sort方法排序，然后取出前N个。最坏时间复杂度达到了$O(n^2)$; 维护一个容量为N的最大堆或者排序二叉树，遍历整个List，取出前面的N个放到堆里。最坏时间复杂度为$O(nlogN)$。 使用Java集合类中的TreeMap可以很容易的实现一个Top-N算法：维护一个大小为N的TreeMaptopN，遍历所有数据，并将其添加到topN中。如果topN.size() &gt; N，就删除topN的第一个元素（值最小的元素）。 以下是示例代码： 1234567891011121314private SortedMap&lt;Double, String&gt; topN(int n, List l)&#123; SortedMap&lt;Double, String&gt; topN = null; if (l != null &amp;&amp; !l.isEmpty())&#123; topN = new TreeMap&lt;Double, String&gt;(); for (DataNode dataNode : l)&#123; topN.put(dataNode.getValue(),dataNode.getkey()); if (topN.size() &gt; n)&#123; topN.remove(topN.firstKey()); &#125; &#125; &#125; return topN;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://voidalex.one/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://voidalex.one/tags/排序/"}]},{"title":"算法笔记：K-means算法及Java实现","slug":"算法笔记：K-means算法及Java实现","date":"2017-08-20T02:53:36.000Z","updated":"2017-08-23T02:13:40.000Z","comments":true,"path":"2017/08/20/算法笔记：K-means算法及Java实现/","link":"","permalink":"https://voidalex.one/2017/08/20/算法笔记：K-means算法及Java实现/","excerpt":"这是voidAlex原创的第六篇博文。源码在我的GitHub 物以类聚，人以群分，人如此，聚类亦如此。","text":"这是voidAlex原创的第六篇博文。源码在我的GitHub 物以类聚，人以群分，人如此，聚类亦如此。 挖坑待填……","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://voidalex.one/tags/算法/"},{"name":"机器学习","slug":"机器学习","permalink":"https://voidalex.one/tags/机器学习/"}]},{"title":"数据归一化的方法","slug":"数据归一化的方法","date":"2017-08-18T08:06:25.000Z","updated":"2017-08-18T09:21:13.000Z","comments":true,"path":"2017/08/18/数据归一化的方法/","link":"","permalink":"https://voidalex.one/2017/08/18/数据归一化的方法/","excerpt":"这是voidAlex原创的第五篇博文。 在数据挖掘的问题中，数据所用的度量单位可能会影响分析结果。使用较小的单位可能会导致该属性有较大的值域。为了避免这些问题，数据应该进行归一化（又称规范化或标准化）。归一化数据将会赋予所有属性相同的权重。常见的归一化方式有三种：最小-最大值归一化，z分数归一化，小数定标归一化。","text":"这是voidAlex原创的第五篇博文。 在数据挖掘的问题中，数据所用的度量单位可能会影响分析结果。使用较小的单位可能会导致该属性有较大的值域。为了避免这些问题，数据应该进行归一化（又称规范化或标准化）。归一化数据将会赋予所有属性相同的权重。常见的归一化方式有三种：最小-最大值归一化，z分数归一化，小数定标归一化。 最小-最大值归一化$$u^\\prime=\\frac{u - min_A}{max_A - min_A}(newmax_A - newmin_A) + newmin_A$$ 其中，A是数值属性，$min_A$和$max_A$分别是属性A在该数据集中的最小和最大值。通过上述的计算即可把A的值映射到区间$[newmin_A, newmax_A]$中的$u^\\prime$。 常用的最小-最大值区间为$[0, 1]$和$[-1, 1]$。使用最小-最大值归一化，如果今后的数据在原始数据的值域之外，将会产生越界错误。 z分数归一化$$u^\\prime=\\frac{u - \\overline{A}}{\\sigma_A}$$ 其中，$\\overline{A}$为属性A的均值，$\\sigma_A$为A的标准差。该方法在属性A的最大最小值未知或者有离群点的时候可用。 小数定标归一化$$u^\\prime=\\frac{u}{10^i}$$ 该方法通过移动属性A的小数点位置进行归一化。小数点移动的位置依赖于A的最大绝对值。其中，$i$是使得$max(\\mid u^\\prime \\mid) &lt; 1$的最小整数。","categories":[],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://voidalex.one/tags/数据挖掘/"},{"name":"数据分析","slug":"数据分析","permalink":"https://voidalex.one/tags/数据分析/"}]},{"title":"算法笔记：一元线性回归及Java实现","slug":"算法笔记：一元线性回归及Java实现","date":"2017-07-23T04:30:50.000Z","updated":"2017-07-31T01:44:26.000Z","comments":true,"path":"2017/07/23/算法笔记：一元线性回归及Java实现/","link":"","permalink":"https://voidalex.one/2017/07/23/算法笔记：一元线性回归及Java实现/","excerpt":"这是voidAlex原创的第四篇博文。源码在我的GitHub","text":"这是voidAlex原创的第四篇博文。源码在我的GitHub 回归问题回归问题是研究自变量和因变量之间关系的一种预测模型技术。例如我们可以通过回归模型去预测房价与房子面积之间的关系，一个人每周花在微信上的时间和他微信好友数量之间的关系等。 回归模型定义了输入和输出的关系。输入为现有信息，输出为预测。 一个预测问题在回归模型下的解决步骤为： 构造训练集； 学习，得到输入输出间的关系； 预测，通过学习得到的关系预测输出。 线性回归假设要使用回归模型预测一个人每周花在微信上的时间和微信好友数量之间的关系，可以用如下的表达式表示： $$ y=ax+b+e $$ 其中，y是你每周需要花费在微信上的时间，x是你的微信好友数量，e是误差。对于误差e，它不是一个定值，有一对y和x，就有一个e，e的值满足正态分布。 假设有数据集： 好友数量 花费的时间 50 55 53 56 80 79 90 88 63 58 89 93 120 90 155 120 将数据集用散点图表示： 我们假定x和y之间的关系确实是线性的，那么可以尝试在散点图上画一条直线： 可以看出，我们能画出很多条直线。接下来就是要从存在的直线中确定一条最佳的直线来拟合数据。 如果存在一条最佳拟合的直线，那么所有的样本数据到这条直线的距离应该是最小的。对于线性回归来说，“最佳”指的就是距离最小化。因此，将参数求解问题转换为求最小误差问题。常见的获得最佳拟合线的方法有最小二乘法、梯度下降算法等。 使用最小二乘法拟合对于上面的样本集，我们尝试用$ y=ax+b+e $去进行拟合，那么可以得到： $$ \\mid e \\mid = \\mid ax + b - y \\mid $$ 误差大小其实就是猜想的$ax + b$的值和观测到的y值之间的差值。把所有的$\\mid e \\mid$都求和，构造一个函数： $$Q = \\sum_{i=1}^n (ax_i + b - y_i)^2$$ 当$Q$最小的时候，即可得到最佳拟合的直线。 可以求导得到$a$和$b$，也可以直接用下面的公式求得：（省略数学推导过程） $$a=\\frac{ \\frac {\\sum_{i = 1}^n y_i \\sum_{i = 1}^n x_i} {n} - \\sum_{i = 1}^n x_i y_i }{ \\frac {\\sum_{i = 1}^n x_i * \\sum_{i = 1}^n x_i} {n} - \\sum_{i = 1}^n x_i^2 }$$ $$b=\\frac {\\sum_{i = 1}^n y_i - a \\sum_{i = 1}^n x_i}{n}$$ 得到$a$和$b$之后，可以用R平方来评估拟合程度： $$R^2=1-\\frac{\\sum_{i=1}^n (y_i - \\hat{y_i})^2}{\\sum_{i=1}^n (y_i - \\bar{y})^2}$$ R平方可以解释为数据集中能够被模型所解释的方差占数据总方差的比重，R平方值越大，说明模型对数据的拟合程度越高。 编码实现首先构造一个类来存放记录： 123456789101112131415161718192021222324public class DataNode &#123; private double x; private double y; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125; public double getXY()&#123; return this.x * this.y; &#125;&#125; 然后构造MyLinearRegression类： 123456789101112131415161718192021222324252627282930313233343536373839public class MyLinearRegression &#123; private List&lt;DataNode&gt; list; private double alpha; private double beta; private double r; public MyLinearRegression(String path) throws IOException&#123; this.list = new ArrayList&lt;DataNode&gt;(); init(path); &#125; public double getAlpha() &#123; return alpha; &#125; public double getBeta() &#123; return beta; &#125; public double getR()&#123; return this.r; &#125; private void init(String path) throws IOException&#123; BufferedReader reader = new BufferedReader(new FileReader(new File(path))); String line = \"\"; while ((line = reader.readLine()) != null)&#123; String str[] = line.split(\",\"); DataNode dataNode = new DataNode(); dataNode.setX(Double.parseDouble(str[0])); dataNode.setY(Double.parseDouble(str[1])); this.list.add(dataNode); &#125; reader.close(); &#125;&#125; 最后要根据读取到的数据去求alpha，beta和r的值。可以直接利用上面的公式： 12345678910111213141516171819202122232425262728293031323334public void getAB()&#123; int n = list.size(); double sumX = 0; double sumY = 0; double sumXY = 0; double sumX2 = 0; for (DataNode dataNode : list)&#123; sumX += dataNode.getX(); sumY += dataNode.getY(); sumXY += dataNode.getXY(); sumX2 += Math.pow(dataNode.getX(), 2); &#125; this.alpha = (((sumY * sumX) / n) - sumXY) / (((sumX * sumX) / n) - sumX2); this.beta = (sumY - this.alpha * sumX) / n;&#125;public void getR2()&#123; double num = 0; double den = 0; double sumY = 0; for (DataNode dataNode : list)&#123; sumY += dataNode.getY(); &#125; double avgY = sumY / list.size(); for (DataNode dataNode : list)&#123; num += Math.pow((dataNode.getY() - (dataNode.getX() * this.alpha + beta)), 2); den += Math.pow((dataNode.getY() - avgY), 2); &#125; this.r = 1 - (num / den);&#125; 使用上述数据集拟合： 1234567891011public class Main &#123; public static void main(String args[]) throws IOException&#123; String path = \"test.txt\"; MyLinearRegression linearRegression = new MyLinearRegression(path); linearRegression.getAB(); linearRegression.getR2(); System.out.println(\"alpha = \" + linearRegression.getAlpha()); System.out.println(\"beta = \" + linearRegression.getBeta()); System.out.println(\"R2 = \" + linearRegression.getR()); &#125;&#125; 得到结果： 123alpha = 0.6058710840658103beta = 26.861280144241604R2 = 0.9001321912140731 所以，拟合该数据集的直线为$y=0.61x+26.86$。 过拟合和欠拟合过拟合过拟合，即在拟合过程中“做过头”。在拟合过程中，可能为了迎合所有的样本甚至是噪声点，使得模型的描述过于复杂，或者失去泛化能力。造成过拟合的原因可能有： 训练样本过少； 迎合了所有的样本甚至是噪声点。 欠拟合欠拟合与过拟合相反，由于操作不当导致模型产生的误差$e$分布过于分散或者太大。欠拟合会因为误差太大导致模型没有泛化能力而失去指导意义。造成欠拟合的方法可能有： 参数过少； 拟合方法不当。 参考资料白话大数据与机器学习 数据科学实战","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://voidalex.one/tags/算法/"},{"name":"机器学习","slug":"机器学习","permalink":"https://voidalex.one/tags/机器学习/"}]},{"title":"Java爬虫：上车吧！爬取妹子图","slug":"Java爬虫：爬取妹子图","date":"2017-07-20T01:10:38.000Z","updated":"2017-07-20T04:56:25.000Z","comments":true,"path":"2017/07/20/Java爬虫：爬取妹子图/","link":"","permalink":"https://voidalex.one/2017/07/20/Java爬虫：爬取妹子图/","excerpt":"这是voidAlex原创的第三篇博文。源码在我的GitHub","text":"这是voidAlex原创的第三篇博文。源码在我的GitHub 爬虫上一篇博文介绍了如何模拟登录和解析JSON数据，这篇博文介绍怎么爬取不需要登录的网站的信息。 上一篇博文中关于爬虫的介绍可以点这里查看。 引入JSOUP在pom.xml中添加JSOUP依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt;&lt;/dependency&gt; JSOUP是一款Java的HTML解析库，可以解析HTML中的文本内容。它的官网地址是https://jsoup.org/。 查看网页源码好了，要干正事了。Google一下妹子图，找到这两个网站：http://jandan.net/ooxx，http://www.youmzi.com/tuinvlang.html.先看第一个，它的源码长这样： 我们要找的是所有的img标签里的URL，然后把它下载下来。但是这样似乎只能爬取单个页面的妹子图？所以我们还要找到下一页的URL： 恩，找到了。开始写代码吧！ downloadImage方法首先写一个下载图片的方法，该方法传入图片的URL和要写入的路径，然后将文件写入本地。需要调用java.net包中的一些方法。 123456789101112131415161718192021222324252627public static boolean downloadImage(String imageUrl, String path) &#123; try &#123; //分割字符串，获得文件名 String filePath = path + imageUrl.substring(imageUrl.lastIndexOf(\"/\")); //获得文件流 URL url = new URL(imageUrl); HttpURLConnection connection = (HttpURLConnection)url.openConnection(); connection.setConnectTimeout(10000); connection.setReadTimeout(10000); InputStream in = connection.getInputStream(); //写入本地文件 File file = new File(filePath); FileOutputStream out = new FileOutputStream(file); int i = 0; while ((i = in.read()) != -1)&#123; out.write(i); &#125; System.out.println(imageUrl + \"下载成功\"); out.close(); in.close(); return true; &#125;catch (Exception e)&#123; System.out.println(imageUrl + \"下载失败\"); return false; &#125;&#125; 需要注意的是要设置超时的时间，要不然会导致很多的图片下载失败。 解析HTML接下来我们需要理一理这个爬虫的思路： 打开这个网页。获取到网页所有图片的URL，然后遍历这些URL去下载图片； 当遍历结束后，去找下一页的URL，然后执行1； 直到找不到下一页的URL为止。 煎蛋妹子图首先用jsoup中的方法获取到网页并且得到Document对象： 12Document doc = null;doc = Jsoup.connect(url).get(); 获得所有的img标签： 1Elements elements = doc.getElementsByTag(\"img\"); 遍历这些标签并且下载： 1234567for (Element element : elements)&#123; //获取标签中src属性的绝对路径 String imgSrc = element.attr(\"abs:src\"); if (downloadImage(imgSrc, path))&#123; count ++; &#125;&#125; 获取下一页的地址，如果没有则退出循环: 1234567try &#123; url = doc.getElementsByClass(\"previous-comment-page\").get(0) .getElementsByTag(\"a\").attr(\"abs:href\");&#125;catch (Exception e)&#123; System.out.println(\"没链接了~\"); break;&#125; 大功告成！ 优妹子第二个网站的略微复杂一点，上方有导航栏，每一页有若干个专题，点击进去了才是大图。所以需要爬取的链接稍微多一点。 首先还是获取到网页并且得到Document对象： 12Document doc = null;doc = Jsoup.connect(url).get(); 然后获得每一个二级页面（即专题）的URL，并放到一个List里面： 12345Elements imageUrl = doc.getElementsByClass(\"tzpic3-mzindex\").get(0).getElementsByTag(\"a\");ArrayList&lt;String&gt; urlList = new ArrayList&lt;String&gt;();for (Element element : imageUrl)&#123; urlList.add(element.attr(\"abs:href\"));&#125; 对于List里的每一个URL，去找它每一个的img标签并且获取下一页的URL： 12345678910111213141516171819202122232425262728293031323334353637383940for (String s : urlList)&#123; String next = s; while (true)&#123; try &#123; doc = Jsoup.connect(next).get(); &#125;catch (IOException e)&#123; System.out.println(url + \"请求失败\"); &#125; Element e = doc.getElementsByClass(\"arpic\").get(0); //获取所有img标签 Elements elements = e.getElementsByTag(\"img\"); for (Element element : elements)&#123; //获取标签中src属性的绝对路径 String imgSrc = element.attr(\"abs:src\"); if (downloadImage(imgSrc, path))&#123; count ++; &#125; &#125; String tmp = next; try &#123; Elements nextPage = doc.getElementsByClass(\"jogger2\").get(0).getElementsByTag(\"a\"); next = null; for (Element element : nextPage)&#123; //获取标签中src属性的绝对路径 if (element.text().equals(\"下一页\"))&#123; next = element.attr(\"abs:href\"); &#125; &#125; &#125;catch (Exception ex)&#123; System.out.println(\"没链接了~\"); break; &#125; if (next == null || tmp.equals(next))&#123; break; &#125; &#125;&#125; 运行12345public static void main(String args[]) throws Exception&#123; String path = \"image\"; jiandan(path); youmeizi(path);&#125; 跑了两个多小时终于跑完了，看一下战果： 恩，将近1w张。不说了，我先喝瓶营养快线去~","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://voidalex.one/tags/爬虫/"},{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"}]},{"title":"Java爬虫：爬取学校教务管理系统的信息","slug":"Java爬虫：爬取学校教务管理系统的信息","date":"2017-07-09T14:15:46.000Z","updated":"2017-07-11T03:32:29.000Z","comments":true,"path":"2017/07/09/Java爬虫：爬取学校教务管理系统的信息/","link":"","permalink":"https://voidalex.one/2017/07/09/Java爬虫：爬取学校教务管理系统的信息/","excerpt":"这是voidAlex原创的第二篇博文。源码在我的GitHub","text":"这是voidAlex原创的第二篇博文。源码在我的GitHub 爬虫关于爬虫是什么就不介绍了。这里简单说一下我所理解的爬虫的思路。 就如同把大象放冰箱里分三步一样，爬虫也分三步。第一步，由于教务管理系统这种网站需要登录才能获取信息，我们需要先用抓包工具抓取原始的请求地址；第二步，获得Cookie，伪装请求模拟登录，然后获得原始数据；第三步，解析数据，得到想要的东西。 抓包学校教务管理系统的地址是http://210.26.111.34/。登录界面长这样： 打开万能的Chrome开发者工具，填好表单点提交，然后在Network中能看到这样的信息： 标记的地方是我们要关注的。第一处能得到登录的请求地址是http://210.26.111.34/mlogin.do，请求方式是POST；第二处能得到请求参数，分别是utype（用户类型），ucode（学号），pwd（密码），rember（记住账号）。原本登录时要输的验证码不见了，interesting。 登录之后通过同样的方式能获取到其他的请求地址，比如成绩，课表，考试安排等等。这里不再一一阐述。 模拟登录用代码模拟登录请求也分三步： 获取该网站的Cookie，并添加到请求头； 添加参数，模拟登录； 得到请求结果。 这里需要用到Apache HttpClient，它是一个支持Http协议的客户端编程工具包。HttpClient的官网是https://hc.apache.org/index.html。 获取Cookie123456BasicCookieStore cookieStore = new BasicCookieStore();CloseableHttpClient httpclient = HttpClients.custom().setDefaultCookieStore(cookieStore).build();HttpGet getCookie = new HttpGet(\"http://210.26.111.34\");CloseableHttpResponse response1 = httpclient.execute(getCookie);response1.close(); 模拟登录构造一个POST请求，将请求参数加进去，用httpclient提交。 12345678HttpUriRequest postLogin = RequestBuilder.post().setUri(new URI(loginUrl)) .addParameter(\"utype\", \"S\") .addParameter(\"ucode\", username) .addParameter(\"pwd\", password) .addParameter(\"rember\", \"true\") .build();CloseableHttpResponse response2 = httpclient.execute(postLogin);response2.close(); 得到结果，解析数据以获取考试成绩为例，通过Chrome开发者工具可以得到考试成绩的原始请求和返回的数据，返回的数据是JSON，这里用Google Gson包去解析。 123456789101112String getExamMark = \"http://210.26.111.34/result/stqryResult/view.do\";HttpUriRequest postExamMark = RequestBuilder.post().setUri(new URI(getExamMark)) .build();CloseableHttpResponse response = httpclient.execute(postExamMark);HttpEntity entity = response.getEntity();String json = EntityUtils.toString(entity);EntityUtils.consume(entity);Gson gson = new Gson();JsonObject jo = gson.fromJson(json, JsonObject.class); 输出结果得到如下信息：12345678&#123;\"footer\":[&#123;\"FE_CU_CREDIT\":\"&lt;b&gt;0&lt;/b&gt;\",\"FE_CU_YEAR\":\"副修学分:\",\"FE_CU_NAME\":\"主修学分:[总分&lt;b&gt;&lt;/b&gt;,必修&lt;b&gt;&lt;/b&gt;]\"&#125;],\"rows\":[&#123;\"FE_CU_NAME\":\"HTML5与JAVASCRIPT\",\"FE_CU_YEAR\":\"2016秋季\",\"FE_CU_CREDIT\":\"3\",\"FE_SR_USUAL1\":86,...省略若干字 成功！ 爬虫刚入门，不足之处欢迎大家批评指正。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://voidalex.one/tags/爬虫/"},{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"}]},{"title":"使用PageRank算法计算球队排名","slug":"使用PageRank算法计算球队排名","date":"2017-07-08T03:27:00.000Z","updated":"2017-07-14T01:38:41.000Z","comments":true,"path":"2017/07/08/使用PageRank算法计算球队排名/","link":"","permalink":"https://voidalex.one/2017/07/08/使用PageRank算法计算球队排名/","excerpt":"这是voidAlex原创的第一篇博文。源码在我的GitHub","text":"这是voidAlex原创的第一篇博文。源码在我的GitHub PageRank算法PageRank算法，又叫佩奇排名。是由Google公司创始人拉里佩奇（Larry Page）发明的一种由搜索引擎根据网页之间相互的超链接计算的技术。 对于某个互联网网页A来说，该网页PageRank的计算基于以下两个基本假设： 数量假设：在Web图模型中，如果一个页面节点接收到的其他网页指向的入链数量越多，那么这个页面越重要； 质量假设：指向页面A的入链质量不同，质量高的页面会通过链接向其他页面传递更多的权重。所以越是质量高的页面指向页面A，则页面A越重要。 根据上面的两个假设，PageRank的计算步骤如下： 网页通过链接关系构建起Web图，每个页面设置相同的PageRank值，通过若干轮的计算，会得到每个页面所获得的最终PageRank值。随着每一轮的计算进行，网页当前的PageRank值会不断得到更新。 在一轮中更新页面PageRank得分的计算方法：在一轮更新页面PageRank得分的计算中，每个页面将其当前的PageRank值平均分配到本页面包含的出链上，这样每个链接即获得了相应的权值。而每个页面将所有指向本页面的入链所传入的权值求和，即可得到新的PageRank得分。当每个页面都获得了更新后的PageRank值，就完成了一轮PageRank计算。 使用PageRank算法计算球队实力将PageRank算法应用到球队中后，球队的PageRank分数的计算依然基于两个假设： 数量假设：比赛中A在其他球队身上取得的分数（战胜或战平）越多，那么这个球队实力越强； 质量假设：取得积分的对手实力强弱不同，实力强的球队会提供更多的权重。所以A取得战胜或战平的球队实力越强，则球队A越强。 利用以上两个假设，PageRank算法刚开始赋予每个球队相同的重要性得分（PR值），通过迭代递归计算来更新每个球队节点的PageRank得分，直到得分稳定为止。 假设一个由4支球队组成的足球联赛：A，B，C和D。给定所有球队一个相同的初始PageRank值PR。在第一轮计算中，对于球队A，假设它在对阵B、C、D球队取得的积分分别为P1、P2、P3，那么它的PageRank值将被更新为： $$ PR(A) = (PR(B)∙P1+PR(C)∙P2+PR(D)∙P3)/3 $$ 同样的，B、C、D队的PageRank值也将通过此方法更新。在进行若干次迭代后，所有球队的PageRank值将会趋向于稳定，也就是收敛状态。这时所有球队的PageRank值就是它们的最终得分。 意义灵感来源于虎扑的一个帖子，里面提到了球队的硬仗能力，或者球队上限。原贴的作者计算了上赛季的英超的PageRank分，自己看了之后比较感兴趣，就实现了一遍。原贴作者提到： 一支球队的联赛排名是其硬仗水平与虐菜能力的共同作用，然而由联赛排名决定的欧战资格，尤其是淘汰赛阶段，更看中的却是球队的硬仗水平，即话题区里所谓的球队上限。于是问题来了，是否存在有些球队主要靠虐菜能力进入欧战区，然后面对他国豪强一泻千里，给本国联赛拖了后腿的情况？我试着用PageRank算法来验证这一猜想。 一支球队的PageRank评分都是从其他球队手中抢来的，要知道一支球队的PageRank评分就必须先知道其他球队的评分，这是鸡生蛋蛋生鸡的难题。PageRank算法的做法是给每个队一个初始分数，比如1，然后通过交战记录互相贡献分数，这样每支队的分数都会有变化；再拿这些分数重复一遍计算，每支队的分数又会变化；重复N次后，变化会趋于0（有数学证明），这时的分数就是最终结果。 一支球队的所谓硬仗能力或球队上限是比较抽（xuan）象（xue）的东西，PageRank算法可以比较好的量化它。 本文中计算了本赛季（2016-2017赛季）英超、西甲、NBA各个球队的PageRank值。数据来源于虎扑。 核心代码核心代码有两部分，PageRank算法和爬虫。 PageRank算法用PageRank算法计算球队PageRank值比较简单。就是通过大量的交手记录来更新PageRank值。计算方法在第二部分已经说明。 用爬虫爬取的球队信息和比赛记录存放在文件中。球队信息以JSON的形式存放，比赛结果以文本的形式存放，一行表示一条比赛记录。类似于： 莱加内斯 2-4 皇马 这样的格式。 首先构造TeamItem类来存放球队信息，该类有两个字段：name和pagerank。 1234567891011121314151617181920212223242526272829303132package com.pagerank.core;/** * 球队类 * Created by 王麟东 on 2017/7/8 0008. */public class TeamItem &#123; private String name; private double pagerank; public TeamItem()&#123; this.pagerank = 1; &#125; public String getName() &#123; return name; &#125; public double getPagerank() &#123; return pagerank; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPagerank(double pagerank) &#123; this.pagerank = pagerank; &#125;&#125; 然后构造MatchResult类来存放比赛结果。在MatchResult类中，有获取比赛结果的方法getWeight。根据比赛结果，返回对应的权重。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.pagerank.core;/** * 比赛结果类 * Created by 王麟东 on 2017/7/8 0008. */public class MatchResult &#123; private String teamA; private String teamB; private int scoreA; private int scoreB; public MatchResult(String line) &#123; String temp[] = line.split(\"-\"); this.teamA = temp[0].split(\" \")[0]; this.scoreA = Integer.parseInt(temp[0].split(\" \")[1]); this.teamB = temp[1].split(\" \")[1]; this.scoreB = Integer.parseInt(temp[1].split(\" \")[0]); &#125; /** * 获得权重（比赛结果） * @param team 球队名 * @return 该球队在本条比赛记录中的比赛结果，胜3平1负0，若本条比赛记录中没有这个球队，返回-1 */ public int getWeight(String team)&#123; int weight = -1; if (team.equals(this.teamA))&#123; if (this.scoreA == this.scoreB)&#123; weight = 1; &#125;else if (this.scoreA &gt; this.scoreB)&#123; weight = 3; &#125;else if (this.scoreA &lt; this.scoreB)&#123; weight = 0; &#125; &#125;else if (team.equals(this.teamB))&#123; if (this.scoreB == this.scoreA)&#123; weight = 1; &#125;else if (this.scoreB &gt; this.scoreA)&#123; weight = 3; &#125;else if (this.scoreB &lt; this.scoreA)&#123; weight = 0; &#125; &#125; return weight; &#125; /** * 在获得比赛权重不为-1的情况下，获得对手球队名 * @param team 球队名 * @return 本条比赛记录中的对手球队名 */ public String getOtherTeam(String team)&#123; String otherTeam = this.teamA; if (team.equals(this.teamA))&#123; otherTeam = this.teamB; &#125; return otherTeam; &#125;&#125; 然后是PageRank类。在PageRank类中，构造方法首先将球队信息和比赛结果读取到内存中，并且给每个球队赋初始PageRank值1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.pagerank.core;import com.google.gson.Gson;import com.google.gson.JsonArray;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by 王麟东 on 2017/7/8 0008. */public class PageRank &#123; private Map&lt;String, TeamItem&gt; teamMap; private List&lt;MatchResult&gt; matchResultList; private String teamInfopath; private String matchResultPath; private int max; public PageRank(String teamInfopath, String matchResultPath, int max)&#123; this.teamInfopath = teamInfopath; this.matchResultPath = matchResultPath; this.max = max; init(); &#125; /** * 初始化，将球队信息和比赛结果读取到内存 */ private void init()&#123; try &#123; BufferedReader teamReader = new BufferedReader(new FileReader(new File(this.teamInfopath))); Gson gson = new Gson(); JsonArray jsonArray = gson.fromJson(teamReader.readLine(), JsonArray.class); teamReader.close(); this.teamMap = new HashMap&lt;String, TeamItem&gt;(); for (JsonElement jsonElement : jsonArray)&#123; TeamItem teamItem = new TeamItem(); teamItem.setName(jsonElement.getAsJsonObject().get(\"team\").getAsString()); this.teamMap.put(teamItem.getName(), teamItem); &#125; BufferedReader matchReader = new BufferedReader(new FileReader(new File(this.matchResultPath))); String line = \"\"; this.matchResultList = new ArrayList&lt;MatchResult&gt;(); while ((line = matchReader.readLine()) != null)&#123; MatchResult matchResult = new MatchResult(line); this.matchResultList.add(matchResult); &#125; matchReader.close(); &#125;catch (IOException e)&#123; System.out.println(\"读取失败\"); System.exit(1); &#125; &#125; public Map&lt;String, TeamItem&gt; getTeamMap() &#123; return teamMap; &#125; public int getMax() &#123; return max; &#125;&#125; 初始化之后，开始递归的计算每个球队的PageRank值： 123456789101112131415161718192021222324252627282930313233/** * PageRank算法迭代器 * @param teamMaps 球队信息 * @param max 迭代次数 */public void Iteration(Map&lt;String, TeamItem&gt; teamMaps, int max)&#123; Map&lt;String, TeamItem&gt; tmp = new HashMap&lt;String, TeamItem&gt;(); for (TeamItem teamItem : teamMaps.values())&#123; TeamItem tmpTeam = new TeamItem(); tmpTeam.setName(teamItem.getName()); double pagerank = 0; int count = 0; for (MatchResult matchResult : this.matchResultList)&#123; int weight = matchResult.getWeight(teamItem.getName()); if (weight != -1)&#123; double pr = teamMaps.get(matchResult.getOtherTeam(teamItem.getName())).getPagerank(); pagerank += (weight * pr); count ++; &#125; &#125; tmpTeam.setPagerank(pagerank / count); tmp.put(tmpTeam.getName(), tmpTeam); &#125; max --; this.teamMap = tmp; if (max &gt; 0)&#123; Iteration(this.teamMap, max); &#125;&#125; 使用爬取的数据测试：12345678String team = \"nba_team_list.json\";String match = \"nba_result_list\";int max = 20;PageRank pageRank = new PageRank(team, match, max);pageRank.Iteration(pageRank.getTeamMap(), pageRank.getMax());pageRank.wirteToFile();pageRank.print(); 由于数据量不大，迭代10-20次已经能够达到收敛状态。 爬虫数据全部来源于虎扑，但是虎扑已经更新到了新赛季（2017-2018赛季）的数据，原来的爬虫失效，所以就不贴出来了。爬取的数据放在我的github。 结果废话不多说，直接上结果。表格中的变化值为相比较原排名的变化程度。 NBA数据为2016-2017赛季常规赛的全部数据。 东部联盟 球队 PageRank 排名 变化值 凯尔特人 1.9366 1 0 猛龙 1.8867 2 +1 骑士 1.8766 3 -1 奇才 1.7852 4 0 老鹰 1.6612 5 0 公牛 1.5974 6 +2 热火 1.5771 7 +2 雄鹿 1.5465 8 -2 步行者 1.5442 9 -2 活塞 1.3974 10 0 黄蜂 1.2995 11 0 尼克斯 1.1173 12 0 魔术 1.0865 13 0 76人 1.0001 14 0 篮网 0.6985 15 0 西部联盟 球队 PageRank 排名 变化值 勇士 2.5695 1 0 马刺 2.3791 2 0 火箭 2.0306 3 0 快船 1.9787 4 0 爵士 1.8741 5 0 雷霆 1.7872 6 0 灰熊 1.7141 7 0 开拓者 1.5253 8 0 掘金 1.4822 9 0 小牛 1.2437 10 +1 鹈鹕 1.2392 11 -1 国王 1.1998 12 0 森林狼 1.1934 13 0 湖人 1.0070 14 0 太阳 0.9156 15 0 西甲数据为2016-2017赛季西甲联赛的全部数据。 球队 PageRank 排名 变化值 巴萨 2.3323 1 +1 皇马 2.2955 2 -1 马竞 1.8039 3 0 塞维利亚 1.7653 4 0 比利亚雷亚尔 1.6181 5 0 毕尔巴鄂 1.4819 6 +1 阿拉维斯 1.4205 7 +2 皇家社会 1.3817 8 -1 埃瓦尔 1.2816 9 +1 西班牙人 1.2111 10 -2 马拉加 1.1516 11 0 瓦伦西亚 1.1018 12 0 塞尔塔 0.9893 13 0 拉斯帕尔马斯 0.9532 14 0 拉科鲁尼亚 0.8892 15 +1 皇家贝蒂斯 0.8815 16 -1 莱加内斯 0.7624 17 0 希洪竞技 0.6651 18 0 格拉纳达 0.5086 19 +1 奥萨苏纳 0.4939 20 -1 英超数据为2016-2017赛季英超联赛的全部数据。 球队 PageRank 排名 变化值 切尔西 5.3667 1 0 热刺 4.9594 2 0 利物浦 4.7785 3 +1 曼城 4.2577 4 -1 阿森纳 4.1272 5 0 曼联 3.9255 6 0 埃弗顿 3.3458 7 0 伯恩茅斯 2.6264 8 +1 莱斯特 2.5141 9 +3 南安普顿 2.4357 10 -2 西汉姆联 2.4165 11 0 水晶宫 2.4097 12 +2 西布朗 2.3787 13 +3 斯旺西 2.3119 14 +1 伯恩利 2.2320 15 +1 沃特福德 2.2083 16 +1 斯托克城 2.1396 17 -4 胡尔城 1.9424 18 0 米德尔斯堡 1.4478 19 0 桑德兰 1.3255 20 0 至于结果能看出来什么信息，大家就见仁见智了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://voidalex.one/tags/Java/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://voidalex.one/tags/数据挖掘/"},{"name":"足球","slug":"足球","permalink":"https://voidalex.one/tags/足球/"},{"name":"算法","slug":"算法","permalink":"https://voidalex.one/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-02T07:33:50.000Z","updated":"2017-07-08T03:24:25.000Z","comments":true,"path":"2017/03/02/hello-world/","link":"","permalink":"https://voidalex.one/2017/03/02/hello-world/","excerpt":"","text":"你好，世界。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://voidalex.one/tags/随笔/"}]}]}